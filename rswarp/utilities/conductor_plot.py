import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.collections import PatchCollection
from matplotlib.gridspec import GridSpec
import functools
from warp import field_solvers
from warp import w3d

# TODO: Configure dielectric patch characteristics (should only have outline)
# TODO: Need Legend scaling and positioning to automatically be set
# TODO: Run everything on call of class instance
# TODO: Allow for manual setup in auto-run fails?
# TODO: Would be nice to have 'run_once' in a central repository location


def run_once(f):

    @functools.wraps(f)
    def f_pass(*args, **kwargs):
        pass

    @functools.wraps(f)
    def run(self, *args, **kwargs):
        try:
            return f(self, *args, **kwargs)
        finally:
            setattr(self, f.__name__, f_pass)

    return run


class PlotConductors(object):
    # Supported conductor types
    conductor_types = ['Box']

    # Attributes template
    conductor_attributes = {'xcent': None,
                            'ycent': None,
                            'zcent': None,
                            'xsize': None,
                            'ysize': None,
                            'zsize': None,
                            'voltage': None,
                            'permeability': None,
                            'permittivity': None}

    def __init__(self, plot_axes=None, xbounds=None, zbounds=None):
        """
        Class for plotting of conductors in 2D (XZ).
        Will plot conductors in simulation domain on an X vs Z plot.
        Bounds and scaling are automatically determined
        Args:
            plot_axes: Optional matplotlib axes object to pass for plotting. Normally the axes object is
            generated by PlotConductors automatically.
            xbounds (tuple)(xmin, xmax): Optional Set bounds in x for plotting.
            Normally determined from Warp values in memory.
            zbounds (tuple)(zmin, zmax): Optional Set bounds in z for plotting.
            Normally determined from Warp values in memory.
        """
        try:
            self.xmin = w3d.xmmin
            self.xmax = w3d.xmmax
            self.zmin = w3d.zmmin
            self.zmax = w3d.zmmax
        except:
            self.xmin = xbounds[0]
            self.xmax = xbounds[1]
            self.zmin = zbounds[0]
            self.zmax = zbounds[1]

        # Try to guess an ideal scaling
        if abs(self.xmax - self.xmin) * 1. > 10.:
            self.scale = 1.
        elif abs(self.xmax - self.xmin) * 1e3 > 1.:
            self.scale = 1e3
        elif abs(self.xmax - self.xmin) * 1e6 > 1.:
            self.scale = 1e6
        else:
            self.scale = 1e9

        self.fig = None
        self.plot_axes = plot_axes
        self.legend_axes = None
        self.conductors = []
        self.voltages = []
        self.dielectrics = []
        self.patches = None
        self.patch_colors = []
        self.legend_handles = []

        # Color options
        self.map = plt.cm.seismic
        self.positive_voltage = self.map(15)
        self.negative_voltage = self.map(240)
        self.ground_voltage = 'grey'
        self.variable_voltage_color = True  # If true use color that varies with voltage, else fixed color for +/-

    @run_once
    def conductor_coordinates(self, solver):
        """
        Runs logic for finding which conductors can be plotted and run appropriate patch creation functions.
        Args:
            solver: Warp fieldsolver object containing conductors to be plotted.

        Returns:
                None
        """

        # Iterate through all conductor lists in the solver
        for key in solver.installedconductorlists:
            # Iterate through all conductor objects
            for conductor in solver.installedconductorlists[key]:
                # Perform check to make sure this is a conductor the code knows how to handle
                for obj_type in self.conductor_types:
                    if isinstance(conductor, getattr(field_solvers.generateconductors, obj_type)):
                        if conductor.voltage is not None:
                            self.conductors.append(self.set_rectangle_patch(conductor))
                            self.voltages.append(conductor.voltage)
                        else:
                            self.dielectrics.append(self.set_rectangle_patch(conductor))
                            # TODO: Will add permittivity when it becomes available

    def conductor_collection(self):
        if not self.plot_axes:
            self.create_axes()

        if self.variable_voltage_color:
            # Min/maxes for linear mapping of voltage to colormap
            negative_min = min(self.voltages)
            negative_max = max([i for i in self.voltages if i < 0.])
            positive_min = min([i for i in self.voltages if i > 0.])
            positive_max = max(self.voltages)

            # Perform mapping
            for voltage in self.voltages:
                if voltage < 0.:
                    try:
                        color = int(-115. / abs(negative_max - negative_min) * voltage + 140.)
                    except ZeroDivisionError:
                        color = 240
                    self.patch_colors.append(self.map(color))
                elif voltage > 0.:
                    try:
                        color = int(-115. / (positive_max - positive_min) * voltage + 115.)
                    except ZeroDivisionError:
                        color = 15
                    self.patch_colors.append(self.map(color))
                elif voltage == 0.:
                        self.patch_colors.append('grey')
        else:
            # Just use same color for all + or - voltages
            for voltage in self.voltages:
                if voltage < 0.:
                    self.patch_colors.append(self.map(240))
                elif voltage > 0.:
                    self.patch_colors.append(self.map(15))
                elif voltage == 0.:
                    self.patch_colors.append('grey')

        # Assign patches for conductors to the plot axes
        self.patches = PatchCollection(self.conductors + self.dielectrics)
        self.patches.set_color(self.patch_colors)
        self.plot_axes.add_collection(self.patches)

        # Setup the legend and set data for legend axes
        self.create_legend()
        self.legend_axes.legend(handles=self.legend_handles,
                                bbox_to_anchor=(2.25, 1.0),
                                borderaxespad=0.,
                                fontsize=5,
                                title='Voltage (V)')

    def set_rectangle_patch(self, conductor):
        """
        Creates a mpl.patches.Rectangle object to represent a box in the XZ plane.
        Args:
            conductor: Warp conductor object

        Returns:
            mpl.patches.Rectangle object

        """
        try:
            x = conductor.zcent
            y = conductor.xcent
            xlength = conductor.zsize
            ylength = conductor.xsize
        except:
            print "Conductor does not have correct attributes to plot: \n{}".format(conductor)
            return

        xcorner = x - xlength / 2.
        ycorner = y - ylength / 2.

        p = patches.Rectangle(
            (xcorner * self.scale, ycorner * self.scale),
            xlength * self.scale,
            ylength * self.scale)

        return p

    def create_axes(self):
        """
        Sets up the plotting region.
        Returns:
            None
        """

        fig = plt.figure()
        gs = GridSpec(1, 2, width_ratios=[20, 1])
        ax1 = fig.add_subplot(gs[0, 0])
        ax2 = fig.add_subplot(gs[0, 1])

        ax2.axis('off')

        ax1.set_xlim(self.zmin * self.scale, self.zmax * self.scale)
        ax1.set_ylim(self.xmin * self.scale, self.xmax * self.scale)

        prefix = '($mm$)' * (self.scale == 1e3) + '($\mu m$)' * (self.scale == 1e6) + \
                 '($nm$)' * (self.scale == 1e9) + '($m$)' * (self.scale == 1.)

        ax1.set_xlabel('z ' + prefix)
        ax1.set_ylabel('x ' + prefix)

        self.fig = fig
        self.plot_axes = ax1
        self.legend_axes = ax2

    @run_once
    def create_legend(self):
        voltage_sort = []
        for voltage, color in zip(self.voltages, self.patch_colors):
            if voltage not in voltage_sort:
                legend_artist = patches.Patch(color=color, label=voltage)
                self.legend_handles.append(legend_artist)
                voltage_sort.append(voltage)

        self.legend_handles = [j for (i, j) in sorted(zip(voltage_sort, self.legend_handles))]


